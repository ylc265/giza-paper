
%%%%%%%%%%%%%%%%%%%%%
% Put
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
  \DontPrintSemicolon
  \SetArgSty{textrm}
  $[f_1, ..., f_n]$ \LAR erasure coded fragments of {\em File}\;
  location\char`_metadata \LAR mapping of coding fragments and their respective data centers\;
  Write location\char`_metadata to local fault tolerant storage\;
  do concurrently:\;
  current\char`_version \LAR Metadata\char`_Put({\em FID}, metadata\char`_location)\;
  send $[f_1, .., f_n]$ to respective data centers\;
  \If{both succeed} {
    \Return {\em current\char`_version}
  } \Else {
    \Return {\em Put-NotOK}
  }
  \caption{Coordinator::\sc{Put}($FID$, $File$) }
  \label{alg:coordinator}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%
% Get
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
  \DontPrintSemicolon
  \SetArgSty{textrm}
  location\char`_metadata \LAR location metadata for the highest version of {\em FID} stored locally\;
  do concurrently:\;
  Get $[f_1, ..., f_n]$ from the data centers recorded in the location\char`_metadata\;
  latest\char`_location\char`_metadata \LAR Metadata\char`_Get({\em FID})\;
  \If{latest\char`_location\char`_metadata is the same as location\char`_metadata} {
    File \LAR decode using $[f_1, ..., f_n]$\;
    \Return {\em File}\;
  } \Else {
    Get $[f_1, ..., f_n]$ from the data centers recorded in latest\char`_location\char`_metadata\;
    File \LAR decode using $[f_1, ..., f_n]$\;
    \Return {\em File}\;
  }
  \caption{Coordinator::\sc{Get}($FID$) }
  \label{alg:coordinator}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%
% Metadata Put
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
  \DontPrintSemicolon
  \SetArgSty{textrm}
  %unsafe log ($T, G$)
%  on first execute \;k
  v \LAR get latest version number of Key from local storage.\;
  \Repeat {Value = decided\char`_value} { 
     v \LAR v + 1 \;
     decided\char`_value \LAR Decide\char`_Value(({\em Key}, v), {\em Value})
  }
  \Return {\em v} \;
  \caption{Coordinator::\sc{Metadata\_Put}($key$, $value$) }
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%
% Metadata Get
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
  \DontPrintSemicolon
  \SetArgSty{textrm}
  %unsafe log ($T, G$)
%  on first execute \;k
  row \LAR retrieve\_fromLocalMetadataTable($key$) \;
  ver \LAR row.read\_col(''latest\_committed\_version'')\;
  $location\_info$ \LAR row.read\_col(ver); \;
  // use $location\_info$ to pre-fetch data fragments in background \;
  \For {each datacenter that stores $key$'s metadata} {
    row \LAR RetrieveFromRemoteMetadataTable($key$)
  }
  %wait until at least receiving a majoriy of replies inlcuding local metadata %row, expecting a fast quorum of replies optimistically.
  wait until receiving a fast quorum of replies including local metadata row. \;
  \If {get a fast quroum that is set *replace this*} {
    $ver'$ \LAR this fast quorum (*replace this* \;
    \If{if $ver' > ver$} {
      $location\_info'$ \LAR write something here *replace this*; \;
      use $location\_info'$ \LAR fetch data fagaments
      decode and return
    } \Else {
      return the prefetched data.
    } 
  }\Else {
    TODO
  }
  
  \caption{Giza::\sc{Get}($Key$)}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%
% Decide_Value
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
  \DontPrintSemicolon
  \SetArgSty{textrm}
  Send Accept({\em Key}, {\em Value}, ballot=0) to all servers in parallel\;
  \If{a fast quorum returns Accept-OKs} {
    run background learning phase\;
    \Return {\em Value}\;
  } \Else {
    goto prepare phase.\;
    
  }
  \underline{Prepare Phase:}\;
  b \LAR highest ballot number seen + 1\;
  send Prepare({\em Key}, ballot=b) to all participating servers\;
  \If{a fast quorum returns Prepare-OKs}{
    {\em Value} = highest accepted value from the fast quorum, if none exists, original value.
    goto accept phase
  } \Else {
    goto prepare phase
  }
  \underline{Accept Phase:}\;
  Send Accept({\em Key}, {\em Value}, ballot=b) to all participating servers\;
  \If{a fast quorum returns Accept-OKs}{
    run background learning phase.\;
    \Return {\em Value}
  } \Else {
    goto prepare phase
  }
 
  \caption{Coordinator::\sc{Decide\char`_Value}($Key$, $Value$) }
  \label{alg:coordinator}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%
% prepare 
%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[h]
  \DontPrintSemicolon
  \SetArgSty{textrm}
  \If{Table[{\em Key}].ballot < {\em ballot}}{
    Table[{\em Key}].ballot = {\em ballot}\;
    \Return {\em Prepare-OK, Table[ Key].accepted\char`_value}
  } \Else {
    \Return Prepare-NotOK
  }
  \caption{Server $S$::\sc{Prepare}($Key$, $ballot$)}
  \label{alg:prepare}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%
% accept
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
  \DontPrintSemicolon
  \SetArgSty{textrm}
  %safe log ($T$, $p$) on first execute \;
  \If{Table[Key].accepted\char`_value is empty and {\em ballot} = 0 or Table[Key].ballot \leq {\em ballot} } {
      Table[Key].accepted\char`_value \LAR {\em Value}\;
	  Table[Key].ballot \LAR {\em ballot}\;
	  Table[Key].accepted\char`_number \LAR {\em ballot}\;
	  \Return {\em Accept-OK}
  }\Else {
      \Return {\em Accept-NotOK}
  }
  \caption{Server $S$::\sc{Accept}($Key$, $Value$, $ballot$)}
  \label{alg:accept}
\end{algorithm}

